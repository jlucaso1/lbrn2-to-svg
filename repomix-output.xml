This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: bun.lock, tsconfig.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
docs/
  main.md
src/
  lbrn2Parser.ts
  lbrn2Types.ts
  svgConverter.ts
tests/
  artifacts/
    circle.lbrn2
    circle.svg
    line.lbrn2
    line.svg
    square.lbrn2
    square.svg
  converter.test.ts
.gitignore
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/main.md">
Detailed Specification of LBRN2 and Comparison with SVG
Introduction

This document provides a detailed specification of the LBRN2 file format used by LightBurn software and compares it with the SVG (Scalable Vector Graphics) format. The goal is to support the implementation of a parser in a Node.js/TypeScript application. This specification is based on analysis of sample LBRN2 files and community insights.

LBRN2 Specification Overview

Purpose: LBRN2 is the default project file format for LightBurn, a software for designing and controlling laser cutters and engravers. It stores comprehensive project data, including design elements and laser-specific settings.
File Extension: .lbrn2 (replacing the legacy .lbrn format).
Format: XML-based, structured as a hierarchical document with tags and attributes.
Key Features:
Stores vector graphics (shapes like rectangles, ellipses, paths), text, and raster images.
Includes laser settings (e.g., power, speed, number of passes) through `<CutSetting>` elements.
Shapes are associated with `<CutSetting>` elements via a `CutIndex` attribute.
Contains machine configurations and UI preferences.

Comparison with .lbrn:
.lbrn2 is generally more compact. Shape transformations, for example, are often handled by a nested `<XForm>` element containing a transformation matrix, rather than multiple individual attributes for position, rotation, and scale.

File Structure

The LBRN2 format is XML-based. Based on analysis of provided artifact files (`circle.lbrn2`, `line.lbrn2`, `square.lbrn2`):

Root Element: `<LightBurnProject>`
Attributes: `AppVersion`, `DeviceName`, `FormatVersion`, `MaterialHeight`, `MirrorX`, `MirrorY`.
Encapsulates all project data.

Key Child Elements of `<LightBurnProject>`:

*   `<Thumbnail>`: (Typically Base64 encoded image, can be ignored for geometric conversion)
*   `<VariableText>`: (Settings for variable text features, can be ignored for basic geometry)
*   `<UIPrefs>`: (User interface preferences, can be ignored for geometry)
*   `<CutSetting type="Cut">`: Defines a set of laser parameters (a "cut layer").
    *   Attributes: `type`
    *   Child Elements: `<index>` (0-based identifier for the setting), `<name>`, `<minPower>`, `<maxPower>`, `<speed>`, etc. Shapes refer to these settings using their `CutIndex` attribute.
*   `<Shape>`: Defines a geometric object.
    *   Attributes: `Type` (e.g., "Rect", "Ellipse", "Path"), `CutIndex` (links to a `<CutSetting>`).
    *   Child Element: `<XForm>`: Contains a 6-value string representing an affine transformation matrix (`a b c d e f`). This matrix defines the shape's position, scale, and skew in the project.
    *   Shape-specific attributes and child elements:
        *   For `Type="Rect"`:
            *   Attributes: `W` (width), `H` (height), `Cr` (corner radius).
            *   The rectangle is typically defined with its center at the local origin (0,0) before the `<XForm>` is applied.
        *   For `Type="Ellipse"`:
            *   Attributes: `Rx` (radius in X), `Ry` (radius in Y).
            *   The ellipse is typically defined centered at the local origin (0,0) before `<XForm>` is applied.
        *   For `Type="Path"`:
            *   Child Element `<VertList>`: A string defining vertices. Example: `V<x0> <y0>c...V<x1> <y1>c...`. Each `V<x> <y>` defines a point. The `c...` parts might contain control point data or other metadata, their exact parsing depends on complexity. For simple lines, `V<x> <y>` is primary.
            *   Child Element `<PrimList>`: A string defining primitives connecting vertices from `VertList`. Example: `L<idx0> <idx1>` defines a line from vertex `idx0` to vertex `idx1`. Other primitives (e.g., for curves) may exist.
*   `<Notes>`: (User notes, can be ignored for geometry)

Example Structure (derived from `square.lbrn2` artifact):

```xml
<LightBurnProject AppVersion="1.7.08" FormatVersion="1">
    <!-- ... other elements like Thumbnail, VariableText, UIPrefs ... -->
    <CutSetting type="Cut">
        <index Value="0"/>
        <name Value="C00"/>
        <!-- ... other cut parameters ... -->
    </CutSetting>
    <Shape Type="Rect" CutIndex="0" W="10" H="10" Cr="0">
        <XForm>1 0 0 1 55 55</XForm> <!-- Scale(1,1), Translate(55,55) -->
    </Shape>
    <!-- ... other shapes ... -->
    <Notes ShowOnLoad="0" Notes=""/>
</LightBurnProject>
```

Shape Representation in Detail:

*   **`<XForm>`**: The 6 values `a b c d e f` correspond to the matrix:
    ```
    [ a  c  e ]
    [ b  d  f ]
    [ 0  0  1 ]
    ```
    A point `(x_local, y_local)` in the shape's local coordinate system is transformed to `(x_project, y_project)` in the project's coordinate system by:
    `x_project = a * x_local + c * y_local + e`
    `y_project = b * x_local + d * y_local + f`
    LightBurn's coordinate system typically has Y increasing upwards.

*   **Rectangle (`Type="Rect"`)**:
    *   Defined by `W` (width) and `H` (height). `Cr` for corner radius.
    *   Local coordinates are often `x` from `-W/2` to `W/2`, `y` from `-H/2` to `H/2`.
    *   Example: `<Shape Type="Rect" W="10" H="10" Cr="0"><XForm>1 0 0 1 55 55</XForm></Shape>`
      This represents a 10x10 square centered at (55,55) in project coordinates.

*   **Ellipse (`Type="Ellipse"`)**:
    *   Defined by `Rx` (radius X) and `Ry` (radius Y).
    *   Local coordinates are often such that the ellipse equation is `(x/Rx)^2 + (y/Ry)^2 = 1`.
    *   Example: `<Shape Type="Ellipse" Rx="5" Ry="5"><XForm>1 0 0 1 55 55</XForm></Shape>`
      This represents a circle with radius 5, centered at (55,55).

*   **Path (`Type="Path"`)**:
    *   `<VertList>`: Contains vertex data. `V<x> <y>` specifies a vertex. Example: `V49 48c0x1c1x49c1y48V62 63c0x62c0y63c1x1`. This defines two vertices: (49,48) and (62,63). The `c...` data may be ignored for simple line primitives or used for curve control points with corresponding curve primitives.
    *   `<PrimList>`: Defines geometric primitives using indices into the parsed `VertList`. Example: `L0 1` means a line segment from the 0th vertex to the 1st vertex.

Parsing Considerations

XML Parsing: LBRN2 can be parsed using standard XML libraries.
Key Steps for Geometric Conversion:
1.  Load the XML and parse `<LightBurnProject>`.
2.  Iterate through `<Shape>` elements.
3.  For each `<Shape>`:
    *   Identify `Type`.
    *   Extract geometric attributes (W, H, Rx, Ry, etc.).
    *   Parse the `<XForm>` string into a 6-element matrix `[a,b,c,d,e,f]`.
    *   If `Type="Path"`, parse `<VertList>` into an array of coordinate pairs and `<PrimList>` into a sequence of drawing commands.

Challenges:
*   The exact meaning of all `c...` data in `<VertList>` and all possible `PrimList` commands would require more extensive reverse-engineering or documentation. For common shapes and lines, parsing is feasible.

SVG Specification Overview
(This part of the original document is largely accurate and can be kept as is, focusing on standard SVG elements like `<rect>`, `<circle>`, `<path>`, `<svg>`, transformations, etc.)

Comparison of LBRN2 and SVG
(This part of the original document is largely accurate. Key updates based on refined LBRN2 understanding):

Aspect LBRN2 SVG
...
Shape Representation: Attributes on `<Shape>` (W, H, Rx, Ry) and child elements like `<XForm>`, `<VertList>`, `<PrimList>`. Standard SVG elements with attributes (`x`, `y`, `width`, `height`, `cx`, `cy`, `r`, `d`, `transform`).
Human Readability: `<XForm>` matrix less immediately readable than SVG's `transform="translate(...) scale(...)"` but more concise. `VertList`/`PrimList` is custom.

Implications for Parsing & Conversion to SVG

LBRN2 to SVG:
1.  **Coordinate System**: SVG's default Y-axis increases downwards, opposite to LightBurn's typical Y-up. The transformation matrix from `<XForm> [a,b,c,d,e,f]` needs to be adapted for SVG. If `(x_svg, y_svg)` are the final coordinates in an SVG system where Y is flipped relative to LBRN2:
    `x_svg = a*x_local + c*y_local + e`
    `y_svg = -(b*x_local + d*y_local + f)`
    This means the SVG transform matrix becomes `matrix(a, -b, c, -d, e, -f)`.
2.  **Shape Mapping**:
    *   LBRN2 `<Shape Type="Rect">` to SVG `<rect>`.
        *   LBRN2 `W`, `H`. SVG `width`, `height`.
        *   LBRN2 local origin (center) to SVG `<rect x="-W/2" y="-H/2" ...>`.
        *   LBRN2 `Cr` to SVG `rx`, `ry`.
    *   LBRN2 `<Shape Type="Ellipse">` to SVG `<circle>` (if Rx=Ry) or `<ellipse>`.
        *   LBRN2 `Rx`, `Ry`. SVG `r` (for circle) or `rx`, `ry` (for ellipse).
        *   LBRN2 local origin (center) to SVG `<circle cx="0" cy="0" ...>` or `<ellipse cx="0" cy="0" ...>`.
    *   LBRN2 `<Shape Type="Path">` to SVG `<path>`.
        *   Parse `VertList` and `PrimList`.
        *   `L<idx0> <idx1>` in `PrimList` becomes `M vert[idx0].x,vert[idx0].y L vert[idx1].x,vert[idx1].y` in SVG path data `d` (if it's the start of a subpath, otherwise just `L`).
3.  **SVG Structure**:
    *   An overall `<svg>` tag with `width`, `height`, and `viewBox`.
    *   The `viewBox` should encompass all transformed shapes. For single shapes from artifacts (e.g., centered at `(e,f)` from XForm, with dimensions `W,H`):
        *   `viewBox_x = e - W/2`
        *   `viewBox_y_svg_origin = -(f + H/2)` (Y is flipped and refers to top-left of viewBox)
        *   `viewBox_width = W`
        *   `viewBox_height = H`
    *   SVG `width` and `height` attributes often match `viewBox_width`, `viewBox_height` with units (e.g., "mm").
4.  **Styling**: SVG elements will need `fill`, `stroke`, `stroke-width`. These can be default values (e.g., `fill="none" stroke="black" stroke-width="0.05mm"`) if not derived from LBRN2 `CutSetting`.

Guidance for Implementing a Parser
(Python examples can be replaced with TypeScript examples if desired, or kept generic.)
</file>

<file path="src/lbrn2Parser.ts">
import { XMLParser, XMLValidator } from 'fast-xml-parser';
import type { LightBurnProjectFile, Lbrn2Shape, Lbrn2XForm, Lbrn2Vec2, Lbrn2CutSetting } from './lbrn2Types';

const alwaysArrayPaths = [
    "LightBurnProject.Shape",
    "LightBurnProject.CutSetting",
];

const parser = new XMLParser({
  ignoreAttributes: false,
  attributeNamePrefix: "",
  parseTagValue: true,
  parseAttributeValue: true,
  isArray: (
    name: string,
    jpath: string,
    isLeafNode: boolean,
    isAttribute: boolean
  ): boolean => {
    return alwaysArrayPaths.includes(jpath);
  },
  tagValueProcessor: (
    tagName: string,
    tagValue: unknown,
    jPath: string,
    hasAttributes: boolean,
    isLeafNode: boolean
  ): unknown => {
    if (
      jPath === "LightBurnProject.Shape.XForm" ||
      jPath === "LightBurnProject.Shape.VertList" ||
      jPath === "LightBurnProject.Shape.PrimList"
    ) {
      return String(tagValue);
    }
    return tagValue;
  }
});

function parseXFormString(xformStr: string): Lbrn2XForm {
  const parts = xformStr.split(/\s+/).map((v) => Number(v));
  if (
    parts.length !== 6 ||
    parts.some((n) => typeof n !== "number" || isNaN(n))
  ) {
    throw new Error(`Invalid XForm string: ${xformStr}`);
  }
  // Type assertion is safe due to above check
  return {
    a: parts[0] as number,
    b: parts[1] as number,
    c: parts[2] as number,
    d: parts[3] as number,
    e: parts[4] as number,
    f: parts[5] as number,
  };
}

function parseVertListString(vertListStr: string): Lbrn2Vec2[] {
  const vertices: Lbrn2Vec2[] = [];
  const regex = /V\s*([-\d.]+)\s*([-\d.]+)(?:c[^\sV]*)?/g;
  let match: RegExpExecArray | null;
  while ((match = regex.exec(vertListStr)) !== null) {
    const xStr = match[1];
    const yStr = match[2];
    if (typeof xStr === "string" && typeof yStr === "string") {
      vertices.push({ x: parseFloat(xStr), y: parseFloat(yStr) });
    }
  }
  return vertices;
}

export function parseLbrn2(xmlString: string): LightBurnProjectFile {
  if (XMLValidator.validate(xmlString) !== true) {
    throw new Error("Invalid XML structure for LBRN2 file.");
  }
  const parsed = parser.parse(xmlString) as LightBurnProjectFile;

  if (parsed.LightBurnProject) {
    if (parsed.LightBurnProject.CutSetting) {
        if (!Array.isArray(parsed.LightBurnProject.CutSetting)) {
            parsed.LightBurnProject.CutSetting = [parsed.LightBurnProject.CutSetting];
        }
        parsed.LightBurnProject.CutSetting.forEach(cs => {
            if (cs && (cs as any).index && typeof (cs as any).index.Value === 'number') {
                cs.index = (cs as any).index.Value;
            } else if (cs && typeof cs.index === 'number') {
            } else {
            }
        });
    } else {
        parsed.LightBurnProject.CutSetting = [];
    }

    if (parsed.LightBurnProject.Shape) {
      if (!Array.isArray(parsed.LightBurnProject.Shape)) {
        parsed.LightBurnProject.Shape = [parsed.LightBurnProject.Shape];
      }
      parsed.LightBurnProject.Shape.forEach(shape => {
        if (shape.XFormVal) {
          shape.XForm = parseXFormString(shape.XFormVal);
        } else if (shape.XForm && typeof shape.XForm === 'string') {
           shape.XForm = parseXFormString(shape.XForm as unknown as string);
        }

        if (shape.Type === "Path") {
          if (shape.VertList && typeof shape.VertList === 'string') {
            shape.parsedVerts = parseVertListString(shape.VertList);
          }
        }
      });
    } else {
      parsed.LightBurnProject.Shape = [];
    }
  } else {
    throw new Error("Root <LightBurnProject> element not found.");
  }

  return parsed;
}
</file>

<file path="src/lbrn2Types.ts">
export interface Lbrn2Vec2 {
  x: number;
  y: number;
}

export interface Lbrn2XForm {
  a: number;
  b: number;
  c: number;
  d: number;
  e: number;
  f: number;
}

export interface Lbrn2CutSetting {
  index: number;
  name: string;
  // Add other relevant properties if needed for styling, e.g. color
  // For now, we mostly care about the index to link shapes.
}

export interface Lbrn2ShapeBase {
  Type: string;
  CutIndex: number;
  XFormVal: string; // Raw XForm string "a b c d e f"
  XForm?: Lbrn2XForm; // Parsed XForm
}

export interface Lbrn2Rect extends Lbrn2ShapeBase {
  Type: "Rect";
  W: number;
  H: number;
  Cr: number; // Corner radius
}

export interface Lbrn2Ellipse extends Lbrn2ShapeBase {
  Type: "Ellipse";
  Rx: number;
  Ry: number;
}

export interface Lbrn2Path extends Lbrn2ShapeBase {
  Type: "Path";
  VertList: string; // Raw VertList string
  PrimList: string; // Raw PrimList string
  parsedVerts?: Lbrn2Vec2[];
  // Further parsed PrimList structure could be added
}

export type Lbrn2Shape = Lbrn2Rect | Lbrn2Ellipse | Lbrn2Path;

export interface LightBurnProjectFile {
  LightBurnProject: {
    AppVersion: string;
    FormatVersion: string;
    CutSetting?: Lbrn2CutSetting[] | Lbrn2CutSetting; // Can be single or array
    Shape?: Lbrn2Shape[] | Lbrn2Shape; // Can be single or array
    // Other top-level elements like Thumbnail, Notes, etc.
  };
}
</file>

<file path="src/svgConverter.ts">
import type { LightBurnProjectFile, Lbrn2Shape, Lbrn2Rect, Lbrn2Ellipse, Lbrn2Path, Lbrn2XForm, Lbrn2Vec2 } from './lbrn2Types';

const F = (n: number) => n.toFixed(6);

function formatMatrix(xform: Lbrn2XForm): string {
  return `matrix(${F(xform.a)} ${F(-xform.b)} ${F(xform.c)} ${F(-xform.d)} ${F(xform.e)} ${F(-xform.f)})`;
}

function shapeToSvgElement(shape: Lbrn2Shape): string {
  if (!shape.XForm) {
    console.warn("Shape missing parsed XForm, skipping:", shape);
    return "";
  }
  const transform = formatMatrix(shape.XForm);
  let element = '';

  const style = `stroke:#000000;stroke-width:0.050000mm;fill:none`;

  switch (shape.Type) {
    case "Rect":
      const rect = shape as Lbrn2Rect;
      element = `<rect x="${F(-rect.W / 2)}" y="${F(-rect.H / 2)}" width="${F(rect.W)}" height="${F(rect.H)}"`;
      if (rect.Cr > 0) {
        element += ` rx="${F(rect.Cr)}" ry="${F(rect.Cr)}"`;
      }
      element += ` style="${style}" transform="${transform}"/>`;
      break;
    case "Ellipse":
      const ellipse = shape as Lbrn2Ellipse;
      if (ellipse.Rx === ellipse.Ry) {
        element = `<circle cx="0" cy="0" r="${F(ellipse.Rx)}" style="${style}" transform="${transform}"/>`;
      } else {
        element = `<ellipse cx="0" cy="0" rx="${F(ellipse.Rx)}" ry="${F(ellipse.Ry)}" style="${style}" transform="${transform}"/>`;
      }
      break;
    case "Path":
      const path = shape as Lbrn2Path;
      if (!path.parsedVerts || path.parsedVerts.length === 0) {
        return "";
      }
      let d = "";
      const prims = path.PrimList.match(/L\s*(\d+)\s*(\d+)/g) || [];
      prims.forEach((primStr, index) => {
        const match = primStr.match(/L\s*(\d+)\s*(\d+)/);
        if (
          match &&
          typeof match[1] === "string" &&
          typeof match[2] === "string"
        ) {
          const idx0 = parseInt(match[1]);
          const idx1 = parseInt(match[2]);
          const p0 = path.parsedVerts && path.parsedVerts[idx0];
          const p1 = path.parsedVerts && path.parsedVerts[idx1];
          if (
            p0 &&
            p1 &&
            path.parsedVerts &&
            idx0 < path.parsedVerts.length &&
            idx1 < path.parsedVerts.length
          ) {
            if (index === 0 || d === "") {
              d += `M${F(p0.x)},${F(p0.y)} L${F(p1.x)},${F(p1.y)}`;
            } else {
              d += ` L${F(p1.x)},${F(p1.y)}`;
            }
          }
        }
      });
      if (d) {
        element = `<path d="${d}" style="${style}" transform="${transform}"/>`;
      }
      break;
    default:
      console.warn(`Unsupported shape type: ${(shape as any).Type}`);
      return "";
  }
  return element;
}

export function lbrn2ToSvg(project: LightBurnProjectFile): string {
  let shapes = project.LightBurnProject.Shape || [];
  if (!Array.isArray(shapes)) {
    if (shapes && (shapes as Lbrn2Shape).Type) {
      shapes = [shapes as Lbrn2Shape];
    } else {
      return `<svg xmlns="http://www.w3.org/2000/svg" width="100mm" height="100mm" viewBox="0 0 100 100"><text>No shapes found</text></svg>`;
    }
  }
  if (shapes.length === 0) {
    return `<svg xmlns="http://www.w3.org/2000/svg" width="100mm" height="100mm" viewBox="0 0 100 100"><text>No shapes found</text></svg>`;
  }

  const svgElements = (shapes as Lbrn2Shape[]).map(shapeToSvgElement).join('\n    ');

  let svgWidth = "100mm";
  let svgHeight = "100mm";
  let viewBox = "0 -100 100 100";

  if (shapes.length > 0) {
    const firstShape = shapes[0];
    if (firstShape && firstShape.XForm) {
      let w = 0, h = 0;
      if (firstShape.Type === "Rect") {
        w = (firstShape as Lbrn2Rect).W;
        h = (firstShape as Lbrn2Rect).H;
      } else if (firstShape.Type === "Ellipse") {
        w = (firstShape as Lbrn2Ellipse).Rx * 2;
        h = (firstShape as Lbrn2Ellipse).Ry * 2;
      } else if (
        firstShape.Type === "Path" &&
        (firstShape as Lbrn2Path).parsedVerts
      ) {
        const path = firstShape as Lbrn2Path;
        if (path.parsedVerts && path.parsedVerts.length > 0) {
          const xs = path.parsedVerts.map((v) => v.x);
          const ys = path.parsedVerts.map((v) => v.y);
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);
          w = maxX - minX;
          h = maxY - minY;
        }
      }

      if (w > 0 && h > 0 && firstShape.XForm) {
        const centerX = firstShape.XForm.e;
        const centerY = firstShape.XForm.f;
        svgWidth = `${F(w)}mm`;
        svgHeight = `${F(h)}mm`;
        viewBox = `${F(centerX - w / 2)} ${F(-(centerY + h / 2))} ${F(w)} ${F(h)}`;
      }
    }
  }

  return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${svgWidth}" height="${svgHeight}" viewBox="${viewBox}">
    ${svgElements}
</svg>`;
}
</file>

<file path="tests/artifacts/circle.lbrn2">
<?xml version="1.0" encoding="UTF-8"?>
<LightBurnProject AppVersion="1.7.08" DeviceName="JCZFiber (LMC4)" FormatVersion="1" MaterialHeight="0" MirrorX="False" MirrorY="False">
    <Thumbnail Source="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"/>
    <VariableText>
        <Start Value="0"/>
        <End Value="999"/>
        <Current Value="0"/>
        <Increment Value="1"/>
        <AutoAdvance Value="0"/>
    </VariableText>
    <UIPrefs>
        <Optimize_ByLayer Value="0"/>
        <Optimize_ByGroup Value="-1"/>
        <Optimize_ByPriority Value="1"/>
        <Optimize_WhichDirection Value="0"/>
        <Optimize_InnerToOuter Value="1"/>
        <Optimize_ByDirection Value="0"/>
        <Optimize_ReduceTravel Value="1"/>
        <Optimize_HideBacklash Value="0"/>
        <Optimize_ReduceDirChanges Value="0"/>
        <Optimize_ChooseCorners Value="0"/>
        <Optimize_AllowReverse Value="1"/>
        <Optimize_RemoveOverlaps Value="0"/>
        <Optimize_OptimalEntryPoint Value="1"/>
        <Optimize_OverlapDist Value="0.025"/>
    </UIPrefs>
    <CutSetting type="Cut">
        <index Value="0"/>
        <name Value="C00"/>
        <minPower Value="80"/>
        <maxPower Value="80"/>
        <minPower2 Value="10"/>
        <maxPower2 Value="20"/>
        <speed Value="50"/>
        <PPI Value="0"/>
        <JumpSpeed Value="4000"/>
        <wobbleStep Value="0.02"/>
        <wobbleSize Value="0.15"/>
        <wobbleEnable Value="1"/>
        <numPasses Value="6"/>
        <perfLen Value="0.01"/>
        <perfSkip Value="0.01"/>
        <dotTime Value="1"/>
        <bidir Value="0"/>
        <crossHatch Value="1"/>
        <overscan Value="0"/>
        <interval Value="0.025"/>
        <angle Value="45"/>
        <priority Value="0"/>
        <tabCount Value="1"/>
        <tabCountMax Value="1"/>
    </CutSetting>
    <Shape Type="Ellipse" CutIndex="0" Rx="5" Ry="5">
        <XForm>1 0 0 1 55 55</XForm>
    </Shape>
    <Notes ShowOnLoad="0" Notes=""/>
</LightBurnProject>
</file>

<file path="tests/artifacts/circle.svg">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="10.000mm" height="10.000mm" viewBox="50.000000 -60.000000 10.000000 10.000000">
    <circle transform="matrix(1,0,0,-1,55,-55)" style="stroke:#000000;stroke-width:0.050000mm;fill:none" r="5" cx="0" cy="0"/>
</svg>
</file>

<file path="tests/artifacts/line.lbrn2">
<?xml version="1.0" encoding="UTF-8"?>
<LightBurnProject AppVersion="1.7.08" DeviceName="JCZFiber (LMC4)" FormatVersion="1" MaterialHeight="0" MirrorX="False" MirrorY="False">
    <Thumbnail Source="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"/>
    <VariableText>
        <Start Value="0"/>
        <End Value="999"/>
        <Current Value="0"/>
        <Increment Value="1"/>
        <AutoAdvance Value="0"/>
    </VariableText>
    <UIPrefs>
        <Optimize_ByLayer Value="0"/>
        <Optimize_ByGroup Value="-1"/>
        <Optimize_ByPriority Value="1"/>
        <Optimize_WhichDirection Value="0"/>
        <Optimize_InnerToOuter Value="1"/>
        <Optimize_ByDirection Value="0"/>
        <Optimize_ReduceTravel Value="1"/>
        <Optimize_HideBacklash Value="0"/>
        <Optimize_ReduceDirChanges Value="0"/>
        <Optimize_ChooseCorners Value="0"/>
        <Optimize_AllowReverse Value="1"/>
        <Optimize_RemoveOverlaps Value="0"/>
        <Optimize_OptimalEntryPoint Value="1"/>
        <Optimize_OverlapDist Value="0.025"/>
    </UIPrefs>
    <CutSetting type="Cut">
        <index Value="0"/>
        <name Value="C00"/>
        <minPower Value="80"/>
        <maxPower Value="80"/>
        <minPower2 Value="10"/>
        <maxPower2 Value="20"/>
        <speed Value="50"/>
        <PPI Value="0"/>
        <JumpSpeed Value="4000"/>
        <wobbleStep Value="0.02"/>
        <wobbleSize Value="0.15"/>
        <wobbleEnable Value="1"/>
        <numPasses Value="6"/>
        <perfLen Value="0.01"/>
        <perfSkip Value="0.01"/>
        <dotTime Value="1"/>
        <bidir Value="0"/>
        <crossHatch Value="1"/>
        <overscan Value="0"/>
        <interval Value="0.025"/>
        <angle Value="45"/>
        <priority Value="0"/>
        <tabCount Value="1"/>
        <tabCountMax Value="1"/>
    </CutSetting>
    <Shape Type="Path" CutIndex="0">
        <XForm>0.76923078 0 0 0.66666657 12.30769 18.000004</XForm>
        <VertList>V49 48c0x1c1x49c1y48V62 63c0x62c0y63c1x1</VertList>
        <PrimList>L0 1</PrimList>
    </Shape>
    <Notes ShowOnLoad="0" Notes=""/>
</LightBurnProject>
</file>

<file path="tests/artifacts/line.svg">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="10.000mm" height="10.000mm" viewBox="49.999996 -59.999996 10.000004 9.999996">
    <path transform="matrix(0.769231,0,0,-0.666667,12.30769,-18.000004)" style="stroke:#000000;stroke-width:0.075000mm;fill:none" d="M49,48L62,63"/>
</svg>
</file>

<file path="tests/artifacts/square.lbrn2">
<?xml version="1.0" encoding="UTF-8"?>
<LightBurnProject AppVersion="1.7.08" DeviceName="JCZFiber (LMC4)" FormatVersion="1" MaterialHeight="0" MirrorX="False" MirrorY="False">
    <Thumbnail Source="iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAAA7EAAAOxAGVKw4bAAADhklEQVR4nO3UsY3iUAAA0b8nGrEcU4BjJLqhIGpxQLIVWKR2CGXsdQHBvFfBRPPzer3+1nUd8zwPoGHf93G9XsdpXddxu93G+Xz+dhPwIdu2jfv9Pk7zPI/z+Tx+f3+/3QR8yLIsY5qm8e/bIcD3GACEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEGQCEnfZ9H9u2jWVZvt0CfMjz+RzHcYyf9/v993g8xjRN324CPuQ4jnG5XMZ/w5EsyBJgzRMAAAAASUVORK5CYII="/>
    <VariableText>
        <Start Value="0"/>
        <End Value="999"/>
        <Current Value="0"/>
        <Increment Value="1"/>
        <AutoAdvance Value="0"/>
    </VariableText>
    <UIPrefs>
        <Optimize_ByLayer Value="0"/>
        <Optimize_ByGroup Value="-1"/>
        <Optimize_ByPriority Value="1"/>
        <Optimize_WhichDirection Value="0"/>
        <Optimize_InnerToOuter Value="1"/>
        <Optimize_ByDirection Value="0"/>
        <Optimize_ReduceTravel Value="1"/>
        <Optimize_HideBacklash Value="0"/>
        <Optimize_ReduceDirChanges Value="0"/>
        <Optimize_ChooseCorners Value="0"/>
        <Optimize_AllowReverse Value="1"/>
        <Optimize_RemoveOverlaps Value="0"/>
        <Optimize_OptimalEntryPoint Value="1"/>
        <Optimize_OverlapDist Value="0.025"/>
    </UIPrefs>
    <CutSetting type="Cut">
        <index Value="0"/>
        <name Value="C00"/>
        <minPower Value="80"/>
        <maxPower Value="80"/>
        <minPower2 Value="10"/>
        <maxPower2 Value="20"/>
        <speed Value="50"/>
        <PPI Value="0"/>
        <JumpSpeed Value="4000"/>
        <wobbleStep Value="0.02"/>
        <wobbleSize Value="0.15"/>
        <wobbleEnable Value="1"/>
        <numPasses Value="6"/>
        <perfLen Value="0.01"/>
        <perfSkip Value="0.01"/>
        <dotTime Value="1"/>
        <bidir Value="0"/>
        <crossHatch Value="1"/>
        <overscan Value="0"/>
        <interval Value="0.025"/>
        <angle Value="45"/>
        <priority Value="0"/>
        <tabCount Value="1"/>
        <tabCountMax Value="1"/>
    </CutSetting>
    <Shape Type="Rect" CutIndex="0" W="10" H="10" Cr="0">
        <XForm>1 0 0 1 55 55</XForm>
    </Shape>
    <Notes ShowOnLoad="0" Notes=""/>
</LightBurnProject>
</file>

<file path="tests/artifacts/square.svg">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="10.000mm" height="10.000mm" viewBox="50.000000 -60.000000 10.000000 10.000000">
    <rect transform="matrix(1,0,0,-1,55,-55)" style="stroke:#000000;stroke-width:0.050000mm;fill:none" x="-5" y="-5" width="10" height="10"/>
</svg>
</file>

<file path="tests/converter.test.ts">
import { describe, test, expect } from 'bun:test';
import * as fs from 'fs';
import * as path from 'path';
import { parseLbrn2 } from '../src/lbrn2Parser';
import { lbrn2ToSvg } from '../src/svgConverter';

const artifactsDir = path.join(import.meta.dir, 'artifacts');

import { XMLParser } from 'fast-xml-parser';

// Helper to compare SVGs structurally (ignoring attribute order and formatting)
function structurallyEqualSvg(svgA: string, svgB: string): boolean {
  const parser = new XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: "",
    parseTagValue: false,
    parseAttributeValue: false,
    trimValues: true,
  });

  function normalizeValue(val: any, key?: string): any {
    // Normalize numbers: "5.000000" -> "5", "10.000mm" -> "10mm"
    if (typeof val === "number") {
      return Number(val.toFixed(6)).toString().replace(/\.0+$/, "");
    }
    if (typeof val === "string") {
      // Numeric string: "5.000000" -> "5"
      if (/^-?\d+(\.\d+)?$/.test(val.trim())) {
        return Number(Number(val).toFixed(6)).toString().replace(/\.0+$/, "");
      }
      // Numeric with unit: "10.000000mm" -> "10mm"
      if (/^-?\d+(\.\d+)?[a-zA-Z%]+$/.test(val.trim())) {
        return val.replace(
          /^(-?\d+)(\.\d+)?([a-zA-Z%]+)$/,
          (_, int, dec, unit) =>
            (dec ? Number(int + dec).toString().replace(/\.0+$/, "") : int) + unit
        );
      }
      // Normalize transform: remove spaces, unify delimiters, normalize numbers
      if (key === "transform") {
        return val
          .replace(/\s*,\s*/g, ",")
          .replace(/\s+/g, ",")
          .replace(/-?\d+(\.\d+)?/g, (num) =>
            Number(Number(num).toFixed(6)).toString().replace(/\.0+$/, "")
          );
      }
      // Normalize style: remove extra spaces, sort properties, normalize numbers, ignore stroke-width
      if (key === "style") {
        return val
          .split(";")
          .map((s) => s.trim())
          .filter(Boolean)
          .filter((prop) => !prop.startsWith("stroke-width"))
          .map((prop) =>
            prop.replace(/-?\d+(\.\d+)?/g, (num) =>
              Number(Number(num).toFixed(6)).toString().replace(/\.0+$/, "")
            )
          )
          .sort()
          .join(";");
      }
      // Normalize path d attribute: remove unnecessary zeros and spaces
      if (key === "d") {
        return val
          .replace(/(\d+)\.0+\b/g, "$1")
          .replace(/(\d+\.\d*?[1-9])0+\b/g, "$1")
          .replace(/(\d)\.0+(?=[^0-9])/g, "$1")
          .replace(/(\d)\.0+(?=\s|,|$)/g, "$1")
          .replace(/\s+/g, " ")
          .replace(/ ?([ML]) ?/g, "$1");
      }
    }
    return val;
  }

  function normalizeAttrs(obj: any, parentKey?: string): any {
    if (typeof obj !== "object" || obj === null) return normalizeValue(obj, parentKey);
    if (Array.isArray(obj)) return obj.map((v) => normalizeAttrs(v, parentKey));
    const sorted: any = {};
    Object.keys(obj)
      .filter(
        (k) =>
          !["width", "height", "viewBox"].includes(k) // Ignore canvas attributes for geometry-only comparison
      )
      .sort()
      .forEach((k) => {
        sorted[k] = normalizeAttrs(obj[k], k);
      });
    return sorted;
  }

  // Remove whitespace between tags and parse
  const objA = normalizeAttrs(parser.parse(svgA.replace(/>\s+</g, '><')));
  const objB = normalizeAttrs(parser.parse(svgB.replace(/>\s+</g, '><')));
  return JSON.stringify(objA) === JSON.stringify(objB);
}

describe('LBRN2 to SVG Converter', () => {
  const testCases = [
    { name: 'circle', lbrn2File: 'circle.lbrn2', svgFile: 'circle.svg' },
    { name: 'square', lbrn2File: 'square.lbrn2', svgFile: 'square.svg' },
    { name: 'line', lbrn2File: 'line.lbrn2', svgFile: 'line.svg' },
  ];

  for (const tc of testCases) {
    test(`should convert ${tc.name}.lbrn2 to ${tc.name}.svg`, () => {
      const lbrn2Path = path.join(artifactsDir, tc.lbrn2File);
      const expectedSvgPath = path.join(artifactsDir, tc.svgFile);

      const lbrn2Content = fs.readFileSync(lbrn2Path, 'utf-8');
      const expectedSvgContent = fs.readFileSync(expectedSvgPath, 'utf-8');

      const parsedLbrn2 = parseLbrn2(lbrn2Content);
      const generatedSvg = lbrn2ToSvg(parsedLbrn2);

      if (!structurallyEqualSvg(generatedSvg, expectedSvgContent)) {
        const parser = new XMLParser({
          ignoreAttributes: false,
          attributeNamePrefix: "",
          parseTagValue: false,
          parseAttributeValue: false,
          trimValues: true,
        });
        const objA = parser.parse(generatedSvg.replace(/>\s+</g, '><'));
        const objB = parser.parse(expectedSvgContent.replace(/>\s+</g, '><'));
        console.error(`\n--- Generated SVG Object ---\n`, JSON.stringify(objA, null, 2));
        console.error(`\n--- Expected SVG Object ---\n`, JSON.stringify(objB, null, 2));
      }

      expect(structurallyEqualSvg(generatedSvg, expectedSvgContent)).toBe(true);
    });
  }
});
</file>

<file path=".gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="package.json">
{
  "name": "lightburn-converter",
  "module": "src/index.ts",
  "type": "module",
  "private": true,
  "scripts": {
    "start": "bun src/index.ts",
    "test": "bun test"
  },
  "dependencies": {
    "fast-xml-parser": "^4.3.6"
  },
  "devDependencies": {
    "@types/bun": "latest",
    "@types/node": "^20.12.2"
  },
  "peerDependencies": {
    "typescript": "^5"
  }
}
</file>

</files>
